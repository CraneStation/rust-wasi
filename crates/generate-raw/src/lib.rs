use heck::*;
use std::io::{Read, Write};
use std::path::Path;
use std::process::{Command, Stdio};
use witx::*;

pub fn generate(wasi: &Path) -> String {
    let doc = witx::load(&[wasi.join("phases/snapshot/witx/wasi_snapshot_preview1.witx")]).unwrap();

    let mut raw = String::new();
    raw.push_str(
        "\
// This file is automatically generated, DO NOT EDIT
//
// To regenerate this file run the `crates/generate-raw` command

use core::mem::MaybeUninit;

mod error;
pub use self::error::Error;
pub type Result<T, E = Error> = core::result::Result<T, E>;
",
    );
    for ty in doc.datatypes() {
        ty.render(&mut raw);
        raw.push_str("\n");
    }
    for m in doc.modules() {
        m.render(&mut raw);
        raw.push_str("\n");
    }

    let mut rustfmt = Command::new("rustfmt")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .unwrap();
    rustfmt
        .stdin
        .take()
        .unwrap()
        .write_all(raw.as_bytes())
        .unwrap();
    let mut ret = String::new();
    rustfmt
        .stdout
        .take()
        .unwrap()
        .read_to_string(&mut ret)
        .unwrap();
    let status = rustfmt.wait().unwrap();
    assert!(status.success());
    return ret;
}

trait Render {
    fn render(&self, src: &mut String);
}

impl Render for Datatype {
    fn render(&self, src: &mut String) {
        match &self.variant {
            witx::DatatypeVariant::Alias(a) => a.render(src),
            witx::DatatypeVariant::Enum(e) => e.render(src),
            witx::DatatypeVariant::Flags(f) => f.render(src),
            witx::DatatypeVariant::Struct(s) => s.render(src),
            witx::DatatypeVariant::Union(s) => s.render(src),
            witx::DatatypeVariant::Handle(s) => s.render(src),
        }
    }
}

impl Render for UnionDatatype {
    fn render(&self, src: &mut String) {
        src.push_str("#[repr(C)]\n");
        src.push_str("#[derive(Copy, Clone)]\n");
        src.push_str(&format!(
            "pub union {} {{\n",
            self.name.as_str().to_camel_case()
        ));
        for variant in self.variants.iter() {
            rustdoc(&variant.docs, src);
            src.push_str("pub ");
            variant.name.render(src);
            src.push_str(": ");
            variant.type_.render(src);
            src.push_str(",\n");
        }
        src.push_str("}");
    }
}

impl Render for StructDatatype {
    fn render(&self, src: &mut String) {
        src.push_str("#[repr(C)]\n");
        src.push_str("#[derive(Copy, Clone)]\n");
        src.push_str(&format!(
            "pub struct {} {{\n",
            self.name.as_str().to_camel_case()
        ));
        for member in self.members.iter() {
            rustdoc(&member.docs, src);
            src.push_str("pub ");
            member.name.render(src);
            src.push_str(": ");
            member.type_.render(src);
            src.push_str(",\n");
        }
        src.push_str("}");
    }
}

impl Render for FlagsDatatype {
    fn render(&self, src: &mut String) {
        src.push_str(&format!(
            "pub type {} = ",
            self.name.as_str().to_camel_case()
        ));
        self.repr.render(src);
        src.push_str(";\n");
        for (i, variant) in self.flags.iter().enumerate() {
            rustdoc(&variant.docs, src);
            src.push_str(&format!(
                "pub const {}_{}: {} = 0x{:x};",
                self.name.as_str().to_shouty_snake_case(),
                variant.name.as_str().to_shouty_snake_case(),
                self.name.as_str().to_camel_case(),
                1 << i
            ));
        }
    }
}

impl Render for EnumDatatype {
    fn render(&self, src: &mut String) {
        src.push_str(&format!(
            "pub type {} = ",
            self.name.as_str().to_camel_case()
        ));
        self.repr.render(src);
        src.push_str(";\n");
        for (i, variant) in self.variants.iter().enumerate() {
            rustdoc(&variant.docs, src);
            src.push_str(&format!(
                "pub const {}_{}: {} = {};",
                self.name.as_str().to_shouty_snake_case(),
                variant.name.as_str().to_shouty_snake_case(),
                self.name.as_str().to_camel_case(),
                i
            ));
        }

        if self.name.as_str() == "errno" {
            src.push_str("fn strerror(code: u16) -> &'static str {");
            src.push_str("match code {");
            for variant in self.variants.iter() {
                src.push_str(&self.name.as_str().to_shouty_snake_case());
                src.push_str("_");
                src.push_str(&variant.name.as_str().to_shouty_snake_case());
                src.push_str(" => \"");
                src.push_str(variant.docs.trim());
                src.push_str("\",");
            }
            src.push_str("_ => \"Unknown error.\",");
            src.push_str("}");
            src.push_str("}");
        }
    }
}

impl Render for IntRepr {
    fn render(&self, src: &mut String) {
        match self {
            IntRepr::U8 => src.push_str("u8"),
            IntRepr::U16 => src.push_str("u16"),
            IntRepr::U32 => src.push_str("u32"),
            IntRepr::U64 => src.push_str("u64"),
        }
    }
}

impl Render for AliasDatatype {
    fn render(&self, src: &mut String) {
        src.push_str(&format!("pub type {}", self.name.as_str().to_camel_case()));
        if self.to.passed_by() == DatatypePassedBy::PointerLengthPair {
            src.push_str("<'a>");
        }
        src.push_str(" = ");

        // Give `size_t` special treatment to translate it to `usize` in Rust
        // instead of `u32`, makes things a bit nicer in Rust.
        if self.name.as_str() == "size" {
            src.push_str("usize");
        } else {
            self.to.render(src);
        }
        src.push(';');
    }
}

impl Render for DatatypeIdent {
    fn render(&self, src: &mut String) {
        match self {
            DatatypeIdent::Builtin(t) => t.render(src),
            DatatypeIdent::Array(t) => {
                src.push_str("&'a [");
                t.render(src);
                src.push_str("]");
            }
            DatatypeIdent::Pointer(t) => {
                src.push_str("*mut ");
                t.render(src);
            }
            DatatypeIdent::ConstPointer(t) => {
                src.push_str("*const ");
                t.render(src);
            }
            DatatypeIdent::Ident(t) => {
                src.push_str(&t.name.as_str().to_camel_case());
            }
        }
    }
}

impl Render for BuiltinType {
    fn render(&self, src: &mut String) {
        match self {
            BuiltinType::String => src.push_str("&str"),
            BuiltinType::U8 => src.push_str("u8"),
            BuiltinType::U16 => src.push_str("u16"),
            BuiltinType::U32 => src.push_str("u32"),
            BuiltinType::U64 => src.push_str("u64"),
            BuiltinType::S8 => src.push_str("i8"),
            BuiltinType::S16 => src.push_str("i16"),
            BuiltinType::S32 => src.push_str("i32"),
            BuiltinType::S64 => src.push_str("i64"),
            BuiltinType::F32 => src.push_str("f32"),
            BuiltinType::F64 => src.push_str("f64"),
        }
    }
}

impl Render for Module {
    fn render(&self, src: &mut String) {
        let rust_name = self.name.as_str().to_snake_case();
        // wrapper functions
        for f in self.funcs() {
            render_highlevel(&f, &rust_name, src);
            src.push_str("\n\n");
        }

        // raw module
        src.push_str("#[allow(non_camel_case_types)]\n");
        src.push_str("pub mod ");
        src.push_str(&rust_name);
        src.push_str("{\nuse super::*;");
        src.push_str("#[link(wasm_import_module =\"");
        src.push_str(self.name.as_str());
        src.push_str("\")]\n");
        src.push_str("extern \"C\" {\n");
        for f in self.funcs() {
            f.render(src);
            src.push_str("\n");
        }
        src.push_str("}");
        src.push_str("}");
    }
}

fn render_highlevel(func: &InterfaceFunc, module: &str, src: &mut String) {
    let rust_name = func.name.as_str().to_snake_case();
    rustdoc(&func.docs, src);
    rustdoc_params(&func.params, "Parameters", src);
    rustdoc_params(&func.results, "Return", src);

    // Render the function and its arguments, and note that the arguments here
    // are the exact type name arguments as opposed to the pointer/length pair
    // ones.
    src.push_str("pub fn ");
    src.push_str(&rust_name);
    src.push_str("(");
    for param in func.params.iter() {
        param.name.render(src);
        src.push_str(": ");
        param.type_.render(src);
        src.push_str(",");
    }
    src.push_str(")");

    // Render the result type of this function, if there is one.
    if let Some(first) = func.results.get(0) {
        // only know how to generate bindings for arguments where the first
        // results is an errno, so assert this here and if it ever changes we'll
        // need to update codegen below.
        assert_eq!(first.name.as_str(), "error");
        src.push_str(" -> Result<");
        // 1 == `Result<()>`, 2 == `Result<T>`, 3+ == `Result<(...)>`
        if func.results.len() != 2 {
            src.push_str("(");
        }
        for result in func.results.iter().skip(1) {
            result.type_.render(src);
            src.push_str(",");
        }
        if func.results.len() != 2 {
            src.push_str(")");
        }
        src.push_str(">");
    }

    src.push_str("{ unsafe {");
    for result in func.results.iter().skip(1) {
        src.push_str("let mut ");
        result.name.render(src);
        src.push_str(" = MaybeUninit::uninit();");
    }
    if func.results.len() > 0 {
        src.push_str("let rc = ");
    }
    src.push_str(module);
    src.push_str("::");
    src.push_str(&rust_name);
    src.push_str("(");

    // Forward all parameters, fetching the pointer/length as appropriate
    for param in func.params.iter() {
        match param.type_.passed_by() {
            DatatypePassedBy::Value(_) => param.name.render(src),
            DatatypePassedBy::Pointer => unreachable!(),
            DatatypePassedBy::PointerLengthPair => {
                param.name.render(src);
                src.push_str(".as_ptr(), ");
                param.name.render(src);
                src.push_str(".len()");
            }
        }
        src.push_str(",");
    }

    // Forward all out-pointers as trailing arguments
    for result in func.results.iter().skip(1) {
        result.name.render(src);
        src.push_str(".as_mut_ptr(),");
    }
    src.push_str(");");

    // Check the return value, and if successful load all of the out pointers
    // assuming they were initialized (part of the wasi contract).
    if func.results.len() > 0 {
        src.push_str("if let Some(err) = Error::from_raw_error(rc) { ");
        src.push_str("Err(err)");
        src.push_str("} else {");
        src.push_str("Ok(");
        if func.results.len() != 2 {
            src.push_str("(");
        }
        for result in func.results.iter().skip(1) {
            result.name.render(src);
            src.push_str(".assume_init(),");
        }
        if func.results.len() != 2 {
            src.push_str(")");
        }
        src.push_str(") }");
    }
    src.push_str("} }");
}

impl Render for InterfaceFunc {
    fn render(&self, src: &mut String) {
        rustdoc(&self.docs, src);
        if self.name.as_str() != self.name.as_str().to_snake_case() {
            src.push_str("#[link_name = \"");
            src.push_str(self.name.as_str());
            src.push_str("\"]\n");
        }
        src.push_str("pub fn ");
        src.push_str(&self.name.as_str().to_snake_case());
        src.push_str("(");
        for param in self.params.iter() {
            param.render(src);
            src.push_str(",");
        }
        for result in self.results.iter().skip(1) {
            result.name.render(src);
            src.push_str(": *mut ");
            result.type_.render(src);
            src.push_str(",");
        }
        src.push_str(")");
        if let Some(result) = self.results.get(0) {
            src.push_str(" -> ");
            result.render(src);
        // special-case the `proc_exit` function for now to be "noreturn", and
        // eventually we'll have an attribute in `*.witx` to specify this as
        // well.
        } else if self.name.as_str() == "proc_exit" {
            src.push_str(" -> !");
        }
        src.push_str(";");
    }
}

impl Render for InterfaceFuncParam {
    fn render(&self, src: &mut String) {
        let is_param = match self.position {
            InterfaceFuncParamPosition::Param(_) => true,
            _ => false,
        };
        match self.type_.passed_by() {
            // By-value arguments are passed as-is
            DatatypePassedBy::Value(_) => {
                if is_param {
                    self.name.render(src);
                    src.push_str(": ");
                }
                self.type_.render(src);
            }
            // Pointer arguments are passed with a `*mut` out in front
            DatatypePassedBy::Pointer => {
                if is_param {
                    self.name.render(src);
                    src.push_str(": ");
                }
                src.push_str("*mut ");
                self.type_.render(src);
            }
            // ... and pointer/length arguments are passed with first their
            // pointer and then their length, as the name would otherwise imply
            DatatypePassedBy::PointerLengthPair => {
                assert!(is_param);
                src.push_str(self.name.as_str());
                src.push_str("_ptr");
                src.push_str(": ");
                src.push_str("*const ");
                match resolve(&self.type_) {
                    DatatypeIdent::Array(x) => x.render(src),
                    DatatypeIdent::Builtin(BuiltinType::String) => src.push_str("u8"),
                    x => panic!("unexpected pointer length pair type {:?}", x),
                }
                src.push_str(", ");
                src.push_str(self.name.as_str());
                src.push_str("_len");
                src.push_str(": ");
                src.push_str("usize");
            }
        }
    }
}

impl Render for Id {
    fn render(&self, src: &mut String) {
        match self.as_str() {
            "in" => src.push_str("r#in"),
            "type" => src.push_str("r#type"),
            s => src.push_str(s),
        }
    }
}

impl Render for HandleDatatype {
    fn render(&self, src: &mut String) {
        drop(src);
        panic!("don't know how to render a handle");
    }
}

fn resolve(ty: &DatatypeIdent) -> &DatatypeIdent {
    if let DatatypeIdent::Ident(i) = ty {
        if let DatatypeVariant::Alias(a) = &i.variant {
            return resolve(&a.to);
        }
    }
    return ty;
}

fn rustdoc(docs: &str, dst: &mut String) {
    if docs.trim().is_empty() {
        return;
    }
    for line in docs.lines() {
        dst.push_str("/// ");
        dst.push_str(line);
        dst.push_str("\n");
    }
}

fn rustdoc_params(docs: &[InterfaceFuncParam], header: &str, dst: &mut String) {
    let docs = docs
        .iter()
        .filter(|param| param.docs.trim().len() > 0)
        .collect::<Vec<_>>();
    if docs.len() == 0 {
        return;
    }

    dst.push_str("///\n");
    dst.push_str("/// ## ");
    dst.push_str(header);
    dst.push_str("\n");
    dst.push_str("///\n");

    for param in docs {
        for (i, line) in param.docs.lines().enumerate() {
            dst.push_str("/// ");
            if i == 0 {
                dst.push_str("* `");
                param.name.render(dst);
                dst.push_str("` - ");
            } else {
                dst.push_str("  ");
            }
            dst.push_str(line);
            dst.push_str("\n");
        }
    }
}
